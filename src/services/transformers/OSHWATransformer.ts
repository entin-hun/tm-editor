/**
 * OSHWA data transformer
 * Transforms OSHWA certification data to ProductInstance objects
 */

import type { ProductInstance, InputInstance } from '@trace.market/types';
import type { OSHWACertification } from '../api/OSHWAClient';
import type {
  ProductInstanceWithSources,
  ProcessInstanceWithSources,
  TransformResult,
} from '../../types/decomposition';
import { CONFIDENCE_PENALTIES } from '../../config/apiConfig';

/**
 * OSHWA transformer
 */
export class OSHWATransformer {
  /**
   * Transform OSHWA certification to ProductInstance
   */
  transform(
    cert: OSHWACertification
  ): TransformResult<ProductInstanceWithSources> {
    const errors: string[] = [];
    const warnings: string[] = [];

    // Validate required fields
    if (!cert.projectName) {
      errors.push('Missing project name');
    }

    // Calculate confidence score
    const confidence = this.calculateConfidence(cert);

    // Build ProductInstance
    const productInstance: ProductInstanceWithSources = {
      type: cert.projectName,
      category: 'hardware',

      // Transform BOM components to inputs
      ...(cert.components &&
        cert.components.length > 0 && {
          inputs: this.transformComponents(cert.components),
        }),

      // Add external source metadata
      externalSources: [
        {
          source: 'OSHWA',
          id: cert.uid,
          url:
            cert.projectUrl ||
            `https://certification.oshwa.org/certification/${cert.uid}`,
          confidence,
          fetchedAt: new Date().toISOString(),
        },
      ],

      // Add decomposition metadata
      decompositionMetadata: {
        autoGenerated: true,
        manuallyEdited: false,
        depth: 0,
        truncated: false,
      },

      // Store OSHWA-specific data
      ...(cert.projectDescription && { description: cert.projectDescription }),
      ...(cert.certificationType && { hardwareType: cert.certificationType }),
      ...(cert.country && { country: cert.country }),
      ...(cert.responsibleParty && { manufacturer: cert.responsibleParty }),
      ...(cert.certificationDate && {
        certificationDate: cert.certificationDate,
      }),
    };

    // Add warnings
    if (!cert.components || cert.components.length === 0) {
      warnings.push('No BOM (Bill of Materials) data available');
    }

    if (!cert.documentation) {
      warnings.push('No documentation links available');
    }

    return {
      data: productInstance,
      confidence,
      errors: errors.length > 0 ? errors : undefined,
      warnings: warnings.length > 0 ? warnings : undefined,
    };
  }

  /**
   * Transform BOM components to InputInstance array
   */
  private transformComponents(
    components: NonNullable<OSHWACertification['components']>
  ): InputInstance[] {
    return components.map((component, index) => {
      // Create inner instance
      const instance = {
        type: component.name || `Component ${index}`,
        category: 'hardware', // Cast or fix type elsewhere
        description: component.description || '',
        quantity: 1, // Standard unit
        bio: false,
        grade: 'standard',
        size: 'standard',
      };

      const inputInstance: any = {
        type: 'local',
        quantity: component.quantity || 1,
        instance: instance as any,
        identifier: component.partNumber || `component-${index}`, // Keep identifier legacy/hack for now? No, use externalSources on instance if needed
      };

      return inputInstance as InputInstance;
    });
  }

  /**
   * Extract assembly process from OSHWA data
   */
  extractAssemblyProcess(
    cert: OSHWACertification
  ): ProcessInstanceWithSources | null {
    if (!cert.components || cert.components.length === 0) {
      return null;
    }

    return {
      type: 'Hardware Assembly',
      category: 'assembly',

      description: `Assembly process for ${cert.projectName}`,

      // Input components
      inputInstances: cert.components.map((component, index) => ({
        identifier: component.partNumber || `component-${index}`,
        category: 'hardware',
        ...(component.name && { name: component.name }),
        ...(component.quantity !== undefined && {
          quantity: component.quantity,
          unit: 'pcs',
        }),
      })),

      // Documentation links
      ...(cert.documentation && {
        documentation: Object.entries(cert.documentation)
          .filter(([, url]) => url)
          .map(([type, url]) => ({
            type,
            url,
          })),
      }),

      // External source metadata
      externalSources: [
        {
          source: 'OSHWA',
          id: cert.uid,
          url:
            cert.projectUrl ||
            `https://certification.oshwa.org/certification/${cert.uid}`,
          confidence: this.calculateConfidence(cert),
          fetchedAt: new Date().toISOString(),
        },
      ],

      decompositionMetadata: {
        autoGenerated: true,
        manuallyEdited: false,
        depth: 0,
        truncated: false,
      },
    };
  }

  /**
   * Calculate confidence score
   */
  calculateConfidence(cert: OSHWACertification): number {
    let confidence = 1.0;

    // Required fields
    if (!cert.projectName) {
      confidence -= CONFIDENCE_PENALTIES.missingRequiredField;
    }

    // Important optional fields
    if (!cert.components || cert.components.length === 0) {
      confidence -= CONFIDENCE_PENALTIES.missingOptionalField * 3; // BOM is very important
    }

    if (!cert.documentation) {
      confidence -= CONFIDENCE_PENALTIES.missingOptionalField;
    }

    if (!cert.projectDescription) {
      confidence -= CONFIDENCE_PENALTIES.missingOptionalField;
    }

    // Ensure confidence is between 0.1 and 1.0
    return Math.max(0.1, Math.min(1.0, confidence));
  }
}

/**
 * Singleton instance
 */
export const oshwaTransformer = new OSHWATransformer();

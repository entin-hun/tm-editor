/**
 * OpenFoodFacts data transformer
 * Transforms OFF API responses to FoodInstance objects
 */

import type {
  FoodInstance,
  InputInstance,
  LocalInputInstance,
  FallbackFoodNutrient,
} from '@trace.market/types';
import type { OFFProductResponse } from '../api/OpenFoodFactsClient';
import type {
  FoodInstanceWithSources,
  TransformResult,
  ExternalDataSource,
} from '../../types/decomposition';
import { CONFIDENCE_PENALTIES } from '../../config/apiConfig';

/**
 * OpenFoodFacts transformer
 */
export class OpenFoodFactsTransformer {
  /**
   * Transform OFF product response to FoodInstance
   */
  transform(
    response: OFFProductResponse
  ): TransformResult<FoodInstanceWithSources> {
    const errors: string[] = [];
    const warnings: string[] = [];
    const product = response.product;

    // Validate required fields
    if (!product) {
      return {
        data: {} as any, // Will be ignored due to errors
        confidence: 0,
        errors: ['Product data missing from API response'],
      };
    }

    if (!product.product_name && !product.product_name_en) {
      errors.push('Missing product name');
    }

    const inputs = product.ingredients
      ? this.transformIngredients(product.ingredients)
      : [];

    // Calculate confidence score
    const confidence = this.calculateConfidence(response);

    // Build FoodInstance
    const foodInstance: FoodInstanceWithSources = {
      type:
        product.product_name || product.product_name_en || 'Unknown Product',
      category: 'food',
      bio: product.labels_tags?.includes('en:organic') ?? false,
      quantity: product.quantity ? parseFloat(product.quantity) || 1 : 1,

      // Transform nutrients
      nutrients: product.nutriments
        ? this.transformNutrients(product.nutriments)
        : undefined,

      // Add external source metadata
      externalSources: [
        {
          source: 'OpenFoodFacts',
          id: response.code,
          url: `https://world.openfoodfacts.org/product/${response.code}`,
          confidence,
          fetchedAt: new Date().toISOString(),
        },
      ],

      // Add decomposition metadata
      decompositionMetadata: {
        autoGenerated: true,
        manuallyEdited: false,
        depth: 0,
        truncated: false,
      },

      // Store additional OFF-specific data as custom properties
      // Note: These would need to be added to FoodInstance type definition
      ...(product.brands && { brands: product.brands }),
      ...(product.categories && { categories: product.categories }),
      ...(product.packaging && { packaging: product.packaging }),
      ...(product.nova_group && { novaGroup: product.nova_group }),
      ...(product.nutrition_grades && {
        nutritionGrade: product.nutrition_grades,
      }),
      ...(product.ecoscore_grade && { ecoScore: product.ecoscore_grade }),
      // quantity is handled explicitly above
      ...(product.manufacturing_places && {
        manufacturingPlaces: product.manufacturing_places,
      }),
      ...(product.origins && { origins: product.origins }),
      ...(product.labels && { labels: product.labels }),
    };

    // Add warnings for missing optional data
    if (!product.ingredients || product.ingredients.length === 0) {
      warnings.push('No ingredients data available');
    }

    if (!product.nova_group) {
      warnings.push('No NOVA processing classification available');
    }

    if (!product.categories) {
      warnings.push('No category information available');
    }

    return {
      data: foodInstance,
      confidence,
      errors: errors.length > 0 ? errors : undefined,
      warnings: warnings.length > 0 ? warnings : undefined,
    };
  }

  /**
   * Transform OFF ingredients to InputInstance array
   */
  public transformIngredients(
    ingredients: OFFProductResponse['product']['ingredients']
  ): InputInstance[] {
    if (!ingredients) return [];

    return ingredients.map((ingredient, index) => {
      // Create a full ProductInstance for the ingredient
      const foodInstance: FoodInstance = {
        type: ingredient.text || ingredient.id,
        category: 'food',
        bio: ingredient.vegan === 'yes', // Heuristic
        quantity: 1, // Standard unit
        price: {
          amount: 0,
          currency: '',
          type: 'budget',
        },

        // Store technical ID in external sources for recursion
        // Note: Casting to any to attach extra metadata not in strict ProductInstance type
        externalSources: [
          {
            source: 'OpenFoodFacts',
            id: ingredient.id,
            url: `https://world.openfoodfacts.org/ingredient/${ingredient.id}`,
            confidence: 0.8,
            fetchedAt: new Date().toISOString(),
          },
        ],
      } as any;

      const inputInstance: any = {
        type: 'local',
        quantity: ingredient.percent_estimate || 0, // Using percent as quantity if available
        priceShare: 0, // Default price share
        instance: foodInstance,
      };

      return inputInstance;
    });
  }

  /**
   * Transform OFF nutrients to FallbackFoodNutrient array
   */
  private transformNutrients(nutriments: any): FallbackFoodNutrient[] {
    if (!nutriments) return [];

    const result: FallbackFoodNutrient[] = [];
    const nutrientMap: Record<string, string> = {
      'energy-kcal': 'Energy (kcal)',
      fat: 'Fat',
      'saturated-fat': 'Saturated Fat',
      carbohydrates: 'Carbohydrates',
      sugars: 'Sugars',
      fiber: 'Fiber',
      proteins: 'Proteins',
      salt: 'Salt',
    };

    for (const [key, label] of Object.entries(nutrientMap)) {
      // OFF returns some values as strings or numbers, sometimes empty strings
      const val = nutriments[key];
      if (val !== undefined && val !== '') {
        const amount = Number(val);
        if (!isNaN(amount)) {
          result.push({
            amount,
            iD: {
              registry: 'OpenFoodFacts',
              id: label,
            },
          });
        }
      }
    }

    return result;
  }

  /**
   * Calculate confidence score based on data completeness
   */
  calculateConfidence(response: OFFProductResponse): number {
    const product = response.product;
    let confidence = 1.0;

    // Required fields
    if (!product.product_name && !product.product_name_en) {
      confidence -= CONFIDENCE_PENALTIES.missingRequiredField;
    }

    // Important optional fields
    if (!product.ingredients || product.ingredients.length === 0) {
      confidence -= CONFIDENCE_PENALTIES.missingOptionalField * 2; // Ingredients are very important
    }

    if (!product.categories) {
      confidence -= CONFIDENCE_PENALTIES.missingOptionalField;
    }

    if (!product.nova_group) {
      confidence -= CONFIDENCE_PENALTIES.missingOptionalField;
    }

    if (!product.packaging) {
      confidence -= CONFIDENCE_PENALTIES.missingOptionalField;
    }

    // Completeness score from OFF (if available)
    if (product.completeness !== undefined) {
      // Use OFF's own completeness assessment
      // Scale: 0-1, where 1 is complete
      confidence *= product.completeness;
    }

    // Data freshness penalty (if last modified timestamp is old)
    if (product.last_modified_t) {
      const ageInYears =
        (Date.now() / 1000 - product.last_modified_t) / (365 * 24 * 60 * 60);
      if (ageInYears > 1) {
        confidence -= Math.min(
          CONFIDENCE_PENALTIES.oldData * ageInYears,
          0.3 // Max 30% penalty for old data
        );
      }
    }

    // Ensure confidence is between 0.1 and 1.0
    return Math.max(0.1, Math.min(1.0, confidence));
  }

  /**
   * Extract process information from NOVA classification
   */
  extractProcessFromNova(novaGroup?: number): {
    processType: string;
    processDescription: string;
  } | null {
    if (!novaGroup) return null;

    const novaDescriptions: Record<
      number,
      { type: string; description: string }
    > = {
      1: {
        type: 'Minimal Processing',
        description:
          'Unprocessed or minimally processed foods - natural foods with no added ingredients.',
      },
      2: {
        type: 'Processed Culinary Ingredients',
        description:
          'Processed culinary ingredients - substances extracted from natural foods or from nature by processes like pressing, grinding, crushing, pulverizing, and refining.',
      },
      3: {
        type: 'Processed Foods',
        description:
          'Processed foods - products made by adding fat, oil, sugar, salt, and other culinary ingredients to minimally processed foods.',
      },
      4: {
        type: 'Ultra-Processing',
        description:
          'Ultra-processed food and drink products - industrial formulations typically with five or more ingredients, including substances not commonly used in culinary preparations.',
      },
    };

    const nova = novaDescriptions[novaGroup];

    if (!nova) return null;

    return {
      processType: nova.type,
      processDescription: nova.description,
    };
  }
}

/**
 * Singleton instance
 */
export const openFoodFactsTransformer = new OpenFoodFactsTransformer();

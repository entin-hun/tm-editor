/**
 * Type definitions for external API integration and product decomposition
 */

import type {
  FoodInstance,
  ProductInstance,
  Process,
  InputInstance,
} from '@trace.market/types';

/**
 * External data source metadata
 * Tracks which API provided which data
 */
export interface ExternalDataSource {
  /** Source name (e.g., "OpenFoodFacts", "OpenLCA", "OSHWA", "WikiFab") */
  source: string;
  /** External identifier (barcode, UUID, UID, etc.) */
  id: string;
  /** Direct URL to the source data */
  url: string;
  /** Confidence score (0.0-1.0) indicating data quality/completeness */
  confidence: number;
  /** ISO timestamp when data was fetched */
  fetchedAt: string;
  /** Optional: Raw API response (stored temporarily for debugging) */
  rawData?: unknown;
}

/**
 * Metadata about decomposition process
 */
export interface DecompositionMetadata {
  /** Whether this data was auto-generated vs manually entered */
  autoGenerated: boolean;
  /** Whether user has manually edited this field */
  manuallyEdited: boolean;
  /** Decomposition depth level (0 = root) */
  depth: number;
  /** Parent product identifier (for recursive decomposition) */
  parentId?: string;
  /** Whether decomposition was truncated (hit depth limit or circular dependency) */
  truncated: boolean;
  /** Reason for truncation, if applicable */
  truncationReason?: 'depth_limit' | 'circular_dependency' | 'api_error';
}

/**
 * Extended FoodInstance with external source metadata
 */
export interface FoodInstanceWithSources extends FoodInstance {
  externalSources?: ExternalDataSource[];
  decompositionMetadata?: DecompositionMetadata;
}

/**
 * Extended ProductInstance with external source metadata
 */
export type ProductInstanceWithSources = ProductInstance & {
  externalSources?: ExternalDataSource[];
  decompositionMetadata?: DecompositionMetadata;
};

/**
 * Extended ProcessInstance with external source metadata
 */
export type ProcessInstanceWithSources = Process & {
  externalSources?: ExternalDataSource[];
  decompositionMetadata?: DecompositionMetadata;
};

/**
 * Decomposition tree node for UI rendering
 */
export interface DecompositionNode {
  /** Unique identifier for this node */
  id: string;
  /** Product/input data */
  data: FoodInstanceWithSources | ProductInstanceWithSources | InputInstance;
  /** Process that creates this product (if applicable) */
  process?: ProcessInstanceWithSources;
  /** Child nodes (inputs/components) */
  children: DecompositionNode[];
  /** Whether node is expanded in tree view */
  expanded: boolean;
  /** Whether node is currently loading data */
  loading: boolean;
  /** Error message if decomposition failed */
  error?: string;
  /** Metadata about this node */
  metadata: DecompositionMetadata;
}

/**
 * Import wizard state
 */
export interface ImportWizardState {
  /** Current step (1-5) */
  currentStep: number;
  /** Selected product type (Food, Hardware, General) */
  productType?: 'Food' | 'Hardware' | 'General';
  /** Search query */
  searchQuery: string;
  /** Search results from APIs */
  searchResults: SearchResult[];
  /** Selected result */
  selectedResult?: SearchResult;
  /** Preview of decomposition tree */
  previewTree?: DecompositionNode;
  /** Loading state */
  loading: boolean;
  /** Error message */
  error?: string;
}

/**
 * Search result from external API
 */
export interface SearchResult {
  /** Source API */
  source: string;
  /** External identifier */
  id: string;
  /** Display name */
  name: string;
  /** Description or summary */
  description?: string;
  /** Thumbnail image URL */
  imageUrl?: string;
  /** Confidence score */
  confidence: number;
  /** Semantic similarity score (0.0-1.0, only present when AI search is used) */
  similarityScore?: number;
  /** Additional metadata (varies by source) */
  metadata?: Record<string, unknown>;
}

/**
 * API client configuration
 */
export interface APIClientConfig {
  /** Base URL for the API */
  baseUrl: string;
  /** Request timeout in milliseconds */
  timeout: number;
  /** Rate limit: max requests per second */
  rateLimit: number;
  /** Cache TTL in seconds (default: 7 days) */
  cacheTtl: number;
  /** Whether authentication is required */
  requiresAuth: boolean;
  /** Authentication credentials (if applicable) */
  auth?: {
    username?: string;
    password?: string;
    apiKey?: string;
    token?: string;
  };
}

/**
 * Cache entry
 */
export interface CacheEntry<T> {
  /** Cache key */
  key: string;
  /** Cached data */
  data: T;
  /** Timestamp when cached */
  cachedAt: number;
  /** TTL in seconds */
  ttl: number;
  /** Cache version (for invalidation) */
  version: number;
}

/**
 * Transformer result
 */
export interface TransformResult<T> {
  /** Transformed data */
  data: T;
  /** Confidence score */
  confidence: number;
  /** Validation errors (if any) */
  errors?: string[];
  /** Warnings about incomplete/missing data */
  warnings?: string[];
}

/**
 * API response wrapper
 */
export interface APIResponse<T> {
  /** Whether request succeeded */
  success: boolean;
  /** Response data (if successful) */
  data?: T;
  /** Error message (if failed) */
  error?: string;
  /** HTTP status code */
  statusCode?: number;
  /** Whether data came from cache */
  fromCache: boolean;
  /** Timestamp */
  timestamp: string;
}
